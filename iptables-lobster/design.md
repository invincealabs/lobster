# iptables -> Lobster Tool Design

## Goals

Given a file generated by the `iptables-save` executable, produce a
Lobster file that encodes those firewall rules.

In particular, we want to handle the SECMARK and CONNSECMARK
extensions to `iptables` that allow for packets to be marked with an
SELinux security context.

We also eventually want to meaningfully translate the matching
arguments of an `iptables` rule into a form that is semantically
meaningful in Lobster. This will support interpretation of those rules
by assertion checkers and other analysis tools.

## Non-Goals

`iptables` is part of the larger Netfilter infrastructure which also
includes filtering capabilities for ARP and bridging (`arptables` and
`ebtables`). Some of the filtering done by these complementary tools
is done between phases of `iptables` filtering, meaning that their
rules might interrupt the flow of a packet through `iptables`
rules.

For this stage of the V3SPA project, we are assuming that there is no
filtering done by any part of Netfilter *except* `iptables`, thus
letting packets unconditionally through any part of the filtering
structure not governed by `iptables`.

## Example cases

- `example.lsr` contains a simple `iptables` setup that whitelists
  particular IP addresses on particular ports, and blocks all other
  traffic.

- `ftp.lsr` is an example from a
  [blog post](http://james-morris.livejournal.com/11010.html)
  demonstrating the interaction between `iptables` and SELinux with
  SECMARK and CONNSECMARK. It adds a security context to any packets
  related to an ftp connection, so that they can participate in
  mandatory access control on the SELinux side.

## Technical Design

The implementation of this tool will proceed in two phases
distinguished by their treatment of the matching arguments to
`iptables` rules. In the first phase, these arguments will be largely
uninterpreted, instead passed along as literal strings to the
constructors of the corresponding Lobster domains. In the second
phase, we will interpret the syntax of matching rules into a
to-be-determined syntax used on the Lobster side.

### Phase One

The tool will produce output similar to the hand-written output in the
example cases. The matching arguments to rules will be left
uninterpreted, but the targets of rules will be interpreted in order
to produce correct port relationships.

#### SECMARK and SELinux

Should a rule target include a SECMARK directive, we will produce an
edge to a stub domain corresponding to the target's SELinux security
context. This will likely then be grafted to a graph produced from
SELinux policy in order to produce a cohesive whole.

#### Parsing

Since we do not need to interpret each of the rules, this phase will
use a very simple parser, probably just using `words` and friends
rather than something more sophisticated like Parsec.

Alternately, we can use the `iptables-helpers` package from Hackage
which, while not perfect, should be able to get us off the ground
quickly.

#### Graph Creation

`iptables` rules can be interpreted as basic blocks in a control flow
graph, so we can apply standard techniques for basic block discovery
as we create the Lobster graph.

We first preprocess all of the chains to discover where rules whose
targets jump to other chains, recording which chains are targeted, and
which rules in the original chain will be run if and when the target
chain matches a RETURN rule.

TODO: we can do better than this, and probably need to if we want to
avoid cycles in the graph. Ideas:

- Make the analysis fully context-sensitive by making a copy of the
  target chain for every jump from a source chain. That way any RETURN
  targets in the copied chain will have an edge to exactly one rule in
  the source chain. This could explode the size of the graph, though.

- Use the context-sensitive approach above, but avoid copying when the
  target chain has no rules with a RETURN target. This yields an
  equivalent but smaller graph.

We start by looking backwards from potential packet destinations
outside the system. For example, packets can eventually reach local
processes in userspace, so we look at the point within the `iptables`
packet flow immediately before they reach that point, in this case the
INPUT chain of the filter table. Finding this point is not always
easy; references like
[this](https://commons.wikimedia.org/wiki/File:Diagrama_linux_netfilter_iptables.gif)
can help tremendously.

Once we've found this point, we work our way backwards through the
rules in that chain, heading in the reverse direction of the usual
fall-through semantics of the rules. When we encounter rules with
targets that alter a packet's flow upon matching, we simply connect
them to the relevant destination, which is usually well-known
(ACCEPT, REJECT, DROP, the first rule of a user-defined chain, etc).

### Phase Two

#### Predicate Language

The focus of this phase is on the definition and implementation of a
predicate language for the semantics of `iptables` matching rules. For
example, a typical `iptables` rule might look like:

    -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT

Ignoring the chain name (`-A INPUT`) and the target (`-j ACCEPT`), we
are left with only the conditions that must be matched for this rule
to fire. In this phase, we will design a translation for these
predicates, for example:

    connection_state = NEW && protocol = tcp && dest_port = 22

This language should be amenable to human inspection and modification,
as well as machine consumption for proof tools and other
manipulations.

In order to check assertions about flows through `iptables` systems,
we need to be able to reason about the conditions which are being
matched, so this encoding must allow us to, for example, check or
refute the feasibility of a conjunction of these matching predicates.

### Open Questions

#### Stateful Features

`iptables` is distinguished from the earlier `ipchains` tool by its
statefulness. This allows rules to match based on previous traffic,
for example a rule might match only if the system sees more than 50
packets per second from the same source. One of the most commonly used
`iptables` extensions, that of connection tracking, relies on this
statefulness to identify packets related to existing connections.

For the purposes of this project, statefulness presents a problem for
precision of the assertion checker. It is straightforward to write a
checker that decides whether a packet's port number or protocol
matches a certain rule. It is far less clear how to write a checker
that handles predicates like "was involved in a previous
connection".

The conservative choice is to assume that *any* packet could be
involved in *any* previous connection, but in practice this would
yield a tremendous number of false positives. Consider this example:

    -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
    -A INPUT -j DROP

The intent of these rules is to accept any attempt to establish a new
connection on port 22, and then accept all subsequent traffic for that
connection. All other traffic is meant to be dropped. Should we make
the conservative approximation that any packet could be involved in
any previous connection, the first rule would match all traffic, and
so all traffic would be accepted. This approximation is too
conservative to be useful.

A similar situation arises with the CONNSECMARK module, which allows
saving and restoring security marks across packets of a
connection. The open question then is how best to encode the semantics
of stateful filters so that we might meaningfully include them in
assertion checking, because they play an essential role in determining
flows.

#### Module Semantics

The previous example also subtly illustrates a second problem. The
first rule matches packets within both established and related
connections. A related connection is one which, while not necessarily
on the same port or protocol as the established connection, can
nonetheless be thought of as part of the same connection.

The canonical example is an FTP server which has separate ports for
control and data transfer. The control port is a fixed well-known
value, but the data transfer ports are dynamically assigned, so they
cannot be statically written into the `iptables` rules.

The `iptables` solution to this uses special-purpose kernel modules
aware of the details of particular protocols. These modules contain
the logic that determines whether a packet is related to an
established connection, and crucially this logic does not appear in
the `iptables` rules themselves. Worse, it is not even clear from the
text of the rules *which* module is relevant for a particular
connection.

This out-of-band logic presents a problem for our assertion
checker. We might encode the semantics of each module in our predicate
language, essentially expanding the `--state ESTABLISHED,RELATED` rule
into a large formula that matches any of the possible known connection
ports. This seems extremely error-prone, as the translation would have
to be done manually, probably through source code inspection of the
modules, and furthermore we might have to vastly expand our predicate
language to encode the types of checks that might be done by arbitrary
module code. For example, deep inspection might be used on an FTP
control packet to learn where an FTP data transfer connection will be
opened.

Another option is to treat these modules as uninterpreted function
symbols within the predicate language. In this scenario, rather than
returning a definite proof or refutation of a particular assertion, a
checker might prove it relative to an assumption about module
semantics. For example, "this port can be reached only by a packet
that is related to an FTP connection".
