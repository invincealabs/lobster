{-# OPTIONS -Wall -Werror #-}
module Main (main) where

import System.Console.GetOpt
import System.Directory
import System.Environment
import System.Exit

import Control.Error (EitherT, hoistEither)

import SCD.M4.ModuleFiles (readPolicy)
import qualified SCD.Lobster.Gen.CoreSyn as L
import SCD.Lobster.Gen.CoreSyn.Output (showLobster)

import qualified M4ToLobster as M4L
import M4ToLobster.Error (Error, runErr, runIO)


main :: IO ()
main = do
  args <- getArgs
  (opts, iDir) <- checkOpt_ args
  lsr <- runErr (dirToLobster iDir opts)
  putStrLn (showLobster lsr)

----------------------------------------------------------------------
-- option handling

data Options = Options
  { path :: FilePath
  , isDir :: Bool
  , ifdefDeclFile :: Maybe FilePath
  , inferMissing :: Bool
--   , kindErrors :: Bool
  , outputMode :: M4L.OutputMode
  } deriving Show

-- | Default options for reference policy processing
defaultOptions :: Options
defaultOptions = Options
  { path = "Gen_Lobster_Dir"
  , isDir = True
  , ifdefDeclFile = Nothing
  , inferMissing = False
--   , kindErrors = False
  , outputMode = M4L.Mode1
  }

options :: [OptDescr (Options -> Options)]
options =
  [ Option [] ["simple"] (NoArg (\o -> o{ outputMode = M4L.Mode2 })) ""
--  , Option [] ["multiple"] (ReqArg (\a o -> o{ path = a, isDir = True }) "FILE") ""
--  , Option [] ["single"] (ReqArg (\a o -> o{ path = a, isDir = False }) "FILE") ""
--  , Option [] ["infer-missing"] (NoArg (\o -> o{ inferMissing = True })) ""
  , Option [] ["ifdefs"] (ReqArg (\f o -> o{ ifdefDeclFile = Just f }) "FILE") ""
--   , Option [] ["kind-errors"] (NoArg (\o -> o{ kindErrors = True })) ""
  ]

printUsage :: IO ()
printUsage = do
  p <- getProgName
  putStrLn $ unlines $
    [ "Usage:"
    , p ++ "[global options] <input directory>"
    , "  Generate lobster policy module(s) from selinux policy in <input directory>"
    , "Global options:"
    , "--simple           Generate one Lobster domain per type, one port per class"
--    , "--single <file>    Place all lobster definitions in a single <file>"
--    , "--multiple <dir>   Generate multiple lobster files and place them in <dir>"
    , "--ifdefs <file>    Read ifdef declarations from <file>"
--    , "--infer-missing    infer missing classes (suitable for graphing by lviz)"
--    , "--kind-errors      Output errors generated by kind checking"
    ]


-- main helper functions

checkOpt_ :: [String] -> IO (Options, FilePath)
checkOpt_ args = do
  (opts,fns) <- checkOpt options defaultOptions args
  case fns of
    [a] -> do
      x <- canonicalizePath a
      return (opts, x)
    _ -> do
      pn <- getProgName
      exitErrors ["expecting: " ++ pn ++ " <input directory>"]

checkOpt :: [OptDescr (a -> a)] -> a -> [String] -> IO (a,[String])
checkOpt os d args =
  case getOpt Permute os args of
    (f, r, [])   -> return (foldl (flip id) d f, r)
    (_, _, errs) -> exitErrors errs

reportErrors :: [String] -> IO ()
reportErrors errs = do
  p <- getProgName
  putStrLn (p ++ ":" ++ concat errs)

exitErrors :: [String] -> IO a
exitErrors errs = do
  reportErrors errs
  printUsage
  exitFailure

-- | Parse a directory containing an SELinux reference policy
-- into Lobster.  If we encounter an error along the way,
-- discard the translation and return the error.
--
-- TODO: Return multiple errors if we can find them.
-- TODO: Redefine "main" in terms of this.
dirToLobster :: FilePath -> Options -> EitherT Error IO [L.Decl]
dirToLobster iDir opts = do
  policy0 <- runIO $ readPolicy (ifdefDeclFile opts) iDir
  hoistEither $ M4L.toLobster (outputMode opts) policy0
