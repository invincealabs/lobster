{-# OPTIONS -Wall #-}
module Main (main) where

import System.Console.GetOpt
import System.Directory
import System.Environment
import System.Exit

import SCD.Lobster.Gen.CoreSyn.Output (showLobster)

import M4ToLobster

main :: IO ()
main = do
  args <- getArgs
  (opts, iDir) <- checkOpt_ args
  lsr <- runErr (toLobster iDir opts)
  putStrLn (showLobster lsr)

----------------------------------------------------------------------
-- option handling

options :: [OptDescr (Options -> Options)]
options =
  [ Option [] ["multiple"] (ReqArg (\a o -> o{ path = a, isDir = True }) "FILE") ""
  , Option [] ["single"] (ReqArg (\a o -> o{ path = a, isDir = False }) "FILE") ""
  , Option [] ["infer-missing"] (NoArg (\o -> o{ inferMissing = True })) ""
  , Option [] ["ifdefs"] (ReqArg (\f o -> o{ ifdefDeclFile = Just f }) "FILE") ""
--   , Option [] ["kind-errors"] (NoArg (\o -> o{ kindErrors = True })) ""
  ]

printUsage :: IO ()
printUsage = do
  p <- getProgName
  putStrLn $ unlines $
    [ "Usage:"
    , p ++ "[global options] <input directory>"
    , "  Generate lobster policy module(s) from selinux policy in <input directory>"
    , "Global options:"
    , "--single <file>    Place all lobster definitions in a single <file>"
    , "--multiple <dir>   Generate multiple lobster files and place them in <dir>"
    , "--ifdefs <file>    Read ifdef declarations from <file>"
    , "--infer-missing    infer missing classes (suitable for graphing by lviz)"
--     , "--kind-errors      Output errors generated by kind checking"
    ]


-- main helper functions

checkOpt_ :: [String] -> IO (Options,FilePath)
checkOpt_ args = do
  (opts,fns) <- checkOpt options defaultOptions args
  case fns of
    [a] -> do
      x <- canonicalizePath a
      return (opts, x)
    _ -> do
      pn <- getProgName
      exitErrors ["expecting: " ++ pn ++ " <input directory>"]

checkOpt :: [OptDescr (a -> a)] -> a -> [String] -> IO (a,[String])
checkOpt os d args =
  case getOpt Permute os args of
    (f, r, [])   -> return (foldl (flip id) d f, r)
    (_, _, errs) -> exitErrors errs

reportErrors :: [String] -> IO ()
reportErrors errs = do
  p <- getProgName
  putStrLn (p ++ ":" ++ concat errs)

exitErrors :: [String] -> IO a
exitErrors errs = do
  reportErrors errs
  printUsage
  exitFailure
